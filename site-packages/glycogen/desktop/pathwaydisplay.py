
import gtk
from glycogen.pathway.pathwaynode import ChallengeNode, ParallelNode, StartNode, EndNode
from glycogen.pathway import pathwayrepo

NODE_SELECTED_COLOUR = gtk.gdk.color_parse("blue")
NODE_COMPLETE_COLOUR = gtk.gdk.color_parse("green")
NODE_INCOMPLETE_COLOUR = gtk.gdk.color_parse("black")

PARALLEL_NODE_END_CAP_FONT_SCALE = 7
NODE_CONNECTOR_FONT_SCALE = 4


def _set_font_params(widget, scale=None, weight=None):
    context = widget.get_pango_context()
    font = context.get_font_description()
    if scale is not None:
        font.set_size(int(font.get_size() * scale))
    if weight is not None:
        font.set_weight(weight)
    widget.modify_font(font)


class PathwayDisplay(gtk.VBox):
    """ Displays a single learning pathway as a pygtk widget """
    
    def __init__(self):
        gtk.VBox.__init__(self, False, 0)
        
        self._topbox = gtk.HBox(False, 0)
        self.pack_start(self._topbox, False, False, 0)
        self._topbox.show()
        
        self._namebox = gtk.Entry()
        self._namebox.set_text("pathway name")
        self._namebox.set_sensitive(False)
        self._namebox.connect('changed', self._change_pathway_name_cb)
        self._topbox.pack_start(self._namebox, False, False, 0)
        self._namebox.set_size_request(400, -1)
        self._namebox.show()
        
        self.btn_save_name = gtk.Button("save name")
        self.btn_save_name.set_sensitive(False)
        self._topbox.pack_start(self.btn_save_name, False, False, 0)
        # button remains hidden until name is changed
        
        self.btn_add_sametime = gtk.Button("same time")
        self._topbox.pack_end(self.btn_add_sametime, False, False, 5)
        self.btn_add_sametime.show()
        
        self.btn_add_after = gtk.Button("after")
        self._topbox.pack_end(self.btn_add_after, False, False, 5)
        self.btn_add_after.show()
        
        self.btn_add_before = gtk.Button("before")
        self._topbox.pack_end(self.btn_add_before, False, False, 5)
        self.btn_add_before.show()
        
        #pathway box goes inside a scrolled window
        
        
        self._pathwaybox = gtk.HBox(False, 0)
        self._pathwaybox.show()
        
        scroll = gtk.ScrolledWindow()
        scroll.add_with_viewport(self._pathwaybox)
        scroll.set_size_request(700, 300)
        scroll.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        scroll.show()
        
        self.pack_start(scroll, True, True, 0)
        
        self._challenge_details = gtk.Label("challenge details")
        self.pack_start(self._challenge_details, True, True, 0)
        self._challenge_details.show()
        
        self.set_pathway(None, None)
        self.refresh()
        
        self.show()
    
    def set_pathway(self, pathway_id, pathway):
        self._pathway = pathway
        self._pathway_id = pathway_id
        if pathway is None:
            self.set_cursor(None)
        else:
            self.set_cursor(pathway.start)
    
    def get_pathway(self):
        return self._pathway
    
    def persist_pathway(self):
        repository = pathwayrepo.get_global_repository()
        id = repository.set_pathway(self._pathway_id, self.get_pathway())
        
    
    def set_cursor(self, node):
        self._cursor = node
        challenge_text = ""
        self.btn_add_before.set_sensitive(False)
        self.btn_add_after.set_sensitive(False)
        self.btn_add_sametime.set_sensitive(False)
        if type(node) is StartNode:
            self.btn_add_after.set_sensitive(True)
        if type(node) is EndNode:
            self.btn_add_before.set_sensitive(True)
        if type(node) is ChallengeNode:
            challenge_text = node.challenge.get_description().format(target=node.challenge.get_result().get_target())
            self.btn_add_before.set_sensitive(True)
            self.btn_add_after.set_sensitive(True)
            self.btn_add_sametime.set_sensitive(True)
        self._challenge_details.set_text(challenge_text)
    
    
    def add_challenge_before(self, challenge):
        pathway = self.get_pathway()
        if pathway is None or challenge is None:
            return
        chal_node = self._build_challenge_pathway_node(challenge)
        self._cursor.add_before(chal_node)
        self.set_cursor(chal_node)
        self.persist_pathway()
        self.refresh()
    
    def add_challenge_after(self, challenge):
        pathway = self.get_pathway()
        if pathway is None or challenge is None:
            return
        chal_node = self._build_challenge_pathway_node(challenge)
        self._cursor.add_after(chal_node)
        self.set_cursor(chal_node)
        self.persist_pathway()
        self.refresh()
        
    def add_challenge_sametime(self, challenge):
        pathway = self.get_pathway()
        if pathway is None or challenge is None:
            return
        chal_node = self._build_challenge_pathway_node(challenge)
        self._cursor.add_below(chal_node)
        self.set_cursor(chal_node)
        self.persist_pathway()
        self.refresh()
    
    def _build_challenge_pathway_node(self, challenge):
        """ Adds the given challenge at the current cursor location
        in the pathway being displayed. This will not automatically
        persist the change """
        if challenge is None:
            raise Exception("challenge is None")
        chal_node = ChallengeNode(None, None, challenge)
        return chal_node
    
    
    def refresh(self):
        """ Refreshes display of this PathwayDisplay's LearningPathway """
        for child in self._pathwaybox.get_children():
            self._pathwaybox.remove(child)
        if self._pathway is None:
            self._namebox.set_text("no pathway")
            self._namebox.set_sensitive(False)
            self.btn_save_name.set_sensitive(False)
            self.btn_save_name.hide()
            self._challenge_details.set_text("")
            return
        self._namebox.set_text(self._pathway.get_name())
        self._namebox.set_sensitive(True)
        self.btn_save_name.set_sensitive(False)
        self.btn_save_name.hide()
        self._pathwaybox.pack_start(self._build_terminal_node(self.get_pathway().start, "start"), True, False, 5)
        self._pathwaybox.pack_end(self._build_terminal_node(self.get_pathway().finish, "end"), True, False, 5)
        self._add_nodes_between(self._pathwaybox, self.get_pathway().start, self.get_pathway().finish)
        
        
    def _build_terminal_node(self, node, label):
        terminal_node = gtk.Button(label)
        terminal_node.pathway_node = node
        self._set_button_colour(terminal_node)
        terminal_node.connect('clicked', self._click_terminal_node_cb)
        terminal_node.show()
        return terminal_node
        
    def _set_button_colour(self, button):
        if button.pathway_node is self._cursor:
            button.modify_bg(gtk.STATE_NORMAL, NODE_SELECTED_COLOUR)
        elif button.pathway_node.complete():
            button.modify_bg(gtk.STATE_NORMAL, NODE_COMPLETE_COLOUR)
        else:
            button.modify_bg(gtk.STATE_NORMAL, NODE_INCOMPLETE_COLOUR)

    
    def _add_nodes_between(self, box, start, end):
        """ Recursively add gtk widget representations of nodes between start and end
        (non inclusive) to the given gtk.Box """
        next = start.after
        while next is not end:
            #TODO replace this simple representation of a connection with something that expands
            connect1 = gtk.Label("-")
            connect2 = gtk.Label("-")
            _set_font_params(connect1, scale=NODE_CONNECTOR_FONT_SCALE)
            _set_font_params(connect2, scale=NODE_CONNECTOR_FONT_SCALE)
            connect1.show()
            connect2.show()
            
            box.pack_start(connect1, True, True, 0)
            box.pack_start(self._build_node(next), False, False, 5) #True, False, 5)
            box.pack_start(connect2, True, True, 0)
            next = next.after
    
    
    def _build_node(self, node):
        if type(node) is ParallelNode:
            return self._build_parallel_node(node)
        if type(node) is ChallengeNode:
            return self._build_challenge_node(node)
        raise Exception("Attempted to build unexpected node type")
        
    def _build_parallel_node(self, node):
        #TODO add curly brace labels before and after
        
        
        top_box = gtk.HBox(False, 5)
        bottom_box = gtk.HBox(False, 5)
        
        node_box = gtk.VBox(False, 5)
        node_box.pack_start(top_box, True, True, 0)
        node_box.pack_start(bottom_box, True, True, 0)
        
        diverge = gtk.Label("{")
        _set_font_params(diverge, scale=PARALLEL_NODE_END_CAP_FONT_SCALE)
        diverge.show()
        converge = gtk.Label("}")
        _set_font_params(converge, scale=PARALLEL_NODE_END_CAP_FONT_SCALE)
        converge.show()
        
        
        outer_box = gtk.HBox(False, 5)
        outer_box.pack_start(diverge, False, False, 0)
        outer_box.pack_start(node_box, True, True, 0)
        outer_box.pack_start(converge, False, False, 0)
        
        self._add_nodes_between(top_box, node.first.top, node.last.top)
        self._add_nodes_between(bottom_box, node.first.bottom, node.last.bottom)
        
        top_box.show()
        bottom_box.show()
        node_box.show()
        outer_box.show()
        
        return outer_box
    
    def _build_challenge_node(self, node):
        #TODO add a tool-tip with description
        #TODO using truncated description - replace this with icon
        label = node.challenge.get_description()[:4]
        chal = gtk.Button(label)
        chal.pathway_node = node
        self._set_button_colour(chal)
        chal.show()
        chal.connect('clicked', self._click_challenge_cb)
        return chal
    
    def _click_terminal_node_cb(self, widget, data=None):
        self.set_cursor(widget.pathway_node)
        self.refresh()
    
    def _click_challenge_cb(self, widget, data=None):
        self.set_cursor(widget.pathway_node)
        self.refresh()
    
    def _set_pathway_name(self, name):
        """ sets pathway name to the given name and persists the
        pathway with the updated name """
        pathway = self.get_pathway()
        if pathway is None:
            return
        pathway.set_name(name)
        self.persist_pathway()
    
    def save_pathway_name(self):
        """ saves the pathway name entered by the user """
        self._set_pathway_name(self._namebox.get_text())
        self.btn_save_name.set_sensitive(False)
        self.btn_save_name.hide()
        
        
    def _change_pathway_name_cb(self, widget, data=None):
        """ callback function to enable the 'save name' button when the user enters a new pathway name """
        self.btn_save_name.set_sensitive(True)
        self.btn_save_name.show()
    
    
    
    
    
