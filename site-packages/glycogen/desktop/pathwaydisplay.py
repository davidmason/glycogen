
import gtk
from glycogen.pathway.learningpathway import LearningPathway
from glycogen.pathway.pathwaynode import ChallengeNode, ParallelNode

class PathwayDisplay(gtk.VBox):
    """ Displays a single learning pathway as a pygtk widget """
    
    def __init__(self):
        gtk.VBox.__init__(self, False, 0)
        
        self._namebox = gtk.Label("pathway name")  #TODO replace with text entry
        self.pack_start(self._namebox, False, False, 0)
        self._namebox.show()
        
        self._pathwaybox = gtk.HBox(False, 0)
        self.pack_start(self._pathwaybox, True, True, 0)
        self._pathwaybox.show()
        
        #FIXME this is a test pathway, remove after testing
        self.set_pathway(LearningPathway())
        self.refresh()
        
        self.show()
    
    def set_pathway(self, pathway):
        self._pathway = pathway
    
    def get_pathway(self):
        return self._pathway
    
    def add_challenge(self, challenge):
        """ Adds the given challenge at the current cursor location
        in the pathway being displayed. This will not automatically
        persist the change """
        
        pathway = self.get_pathway()
        
        if pathway is None:
            #return  #can't add to null pathway. TODO consider throwing exception
            raise Exception("pathway is None")
        
        if challenge is None:
            #return  #can't add no challenge. TODO consider throwing exception
            raise Exception("challenge is None")
        
        #TODO just using set position at end for now
        
        
        chal_node = ChallengeNode(None, None, challenge)
        pathway.start.add_after(chal_node)
        
        self.set_pathway(pathway)
        
        self.refresh()
    
    
    #TODO method to display pathway by id - retrieve pathway from repository
    
    def refresh(self):
        """ Refreshes display of this PathwayDisplay's LearningPathway """
        
        for child in self._pathwaybox.get_children():
            self._pathwaybox.remove(child)
        
        if self._pathway is None:
            self._namebox.set_text("no pathway")
            return
        
        self._namebox.set_text(self._pathway.get_name())
        
        self._pathwaybox.pack_start(self._build_start_node(), False, False, 0)
        self._pathwaybox.pack_end(self._build_end_node(), False, False, 0)
        
        self._add_nodes_between(self._pathwaybox, self.get_pathway().start, self.get_pathway().finish)
        
    def _build_start_node(self):
        start_node = gtk.Button("start")
        start_node.show()
        return start_node
        
    def _build_end_node(self):
        end_node = gtk.Button("end")
        end_node.show()
        return end_node
    
    def _add_nodes_between(self, box, start, end):
        """ Recursively add gtk widget representations of nodes between start and end
        (non inclusive) to the given gtk.Box """
        
        box.pack_start
        
        
        next = start.after
        
        while next is not end:
            box.pack_start(self._build_node(next), False, False, 0)
            next = next.after
    
    
    def _build_node(self, node):
        if type(node) is ParallelNode:
            return self._build_parallel_node(node)
        if type(node) is ChallengeNode:
            return self._build_challenge_node(node)
        raise Exception("Attempted to build unexpected node type")
        
    def _build_parallel_node(self, node):
        #make self as VBox
        node_box = gtk.VBox(False, 0)
        top_box = gtk.HBox(False, 0)
        bottom_box = gtk.HBox(False, 0)
        node_box.pack_start(top_box, True, True, 0)
        node_box.pack_start(bottom_box, True, True, 0)
        
        self._add_nodes_between(top_box, node.first.top, node.last.top)
        self._add_nodes_between(bottom_box, node.first.bottom, node.last.bottom)
        
        top_box.show()
        bottom_box.show()
        node_box.show()
        
        return node_box
    
    def _build_challenge_node(self, node):
        #TODO make this have a tool-tip
        #TODO different icon depending whether the challenge is complete
        
        #TODO initially just use simple text (truncate description)?
        
        chal = gtk.Label("challenge")
        chal.show()
        
        return chal
        
        #if node.challenge.complete():
        #    return gtk.Label("complete")
        #else:
        #    return gtk.Label("incomplete")
    
    
    
    
    
    
    
