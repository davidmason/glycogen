
import os
import pickle

#TODO figure out what is the best path to use here
#CHALLENGE_FILE_PATH = '/tmp/glycogen/challenges'
CHALLENGE_FILE_PATH = '/home/sugar/challengies/chal'


# utility method to make sure the directory exists to put the challenges in
def ensure_dir(file_path):
    directory = os.path.dirname(file_path)
    if directory:
        if not os.path.exists(directory):
            os.makedirs(directory)

class ChallengeRepo():

    #self._challenges is a map with bundle id as key, and a map of challenges as values
    # the challenge maps have challenge id as keys, and a map or challenge type as values
    # (details of types still to be determined during development)

    def __init__(self):
        # Unpickle list of challenges if present
        ensure_dir(CHALLENGE_FILE_PATH)
        try:
            f = open(CHALLENGE_FILE_PATH, 'r')
            self._challenges = pickle.load(f)
            f.close()
        except IOError:
            # file doesn't exist, use empty map
            self._challenges = {}

    def persist_challenges(self):
        ensure_dir(CHALLENGE_FILE_PATH)
        try:
            f = open(CHALLENGE_FILE_PATH, 'w')  # write mode to replace any old version of the file
            #TODO need to make sure that changes aren't going to be lost with multiple instances
            # overwriting each other. For now just stick to workflows that will prevent this.
            pickle.dump(self._challenges, f)
            f.close()
        except IOError:
            raise IOError('unable to save challenges')


    def set_challenges(self, bundle_id, challenge_map):
        """ Overwrite any existing challenges for this activity with the
        given challenges.

        challenge_map should use a challenge id as key, which can be
        anything as long as it is unique for the activity.

        """

        #TODO error checking here to make sure arguments are valid

        self._challenges[bundle_id] = challenge_map

    #a couple of test methods to make sure I can persist things during a session
    def add_challenge(self, challenge):
        """ challenge is just a string for now, for testing """
        self._challenges['challenge'] = challenge
        self.persist_challenges()

    def update_achievement(self, achievement):
        """ achievement is just a string for now, for testing """
        self._challenges['achievement'] = achievement
        self.persist_challenges()



    # Things we need:

    # Map of all the challenges in each activity
    
    # Challenge has: activity_id, challenge_id, description, result type, result reporting method
    # result reporting method may be complicated to access, it should be a module method with no
    # class to have to instantiate, so don't worry about it if it is too complicated, instead
    # just do something with tuples that are either format strings (for numbers) or different
    # messages (for booleans)
    
    # RESULTS
    # Results can be int, float, percentage, boolean
    # Reporting method takes the target and the actual and returns a formatted
    # string indicating success or failure. The method should also return a
    # boolean to indicate complete or not (returns a tuple).

    # could make a challenge result class that is a wrapper for all challenge
    # results of every type, used to store the value and return it, so that
    # they can easily be passed around without any consideration for the type
    # they are, plus the type could be determined without reflection

    # In python it may be better just to reflect it, although that does
    # allow more leeway for things to go wrong.

    # Target results could be stored in the result wrapper too. Developer can
    # then unwrap them in the comparison method, compare, and respond appropriately


    # Map of current achievements (a challenge and a result)
    

# This is probably a better alternative to a singleton implementation
# It is certainly a lot clearer and simpler

_repo_instance = None

def get_global_repository():  # named to make it clear that a single global repo is used
    if globals()['_repo_instance'] is None:
        globals()['_repo_instance'] = ChallengeRepo()
    return globals()['_repo_instance']


if __name__ == '__main__':
    r1 = get_global_repository()
    print r1._challenge
    r1.add_challenge("adding challenge")
    print r1._challenge

    r2 = get_global_repository()
    print r2._challenge
