
import os
import pickle

#TODO figure out what is the best path to use here
#TODO possibly use one file per bundle id, to improve stability and performance
#CHALLENGE_FILE_PATH = '/tmp/glycogen/challenges'
CHALLENGE_FILE_PATH = '/home/sugar/challenges/chal'


# utility method to make sure the directory exists to put the challenges in
def _ensure_dir(file_path):
    directory = os.path.dirname(file_path)
    if directory:
        if not os.path.exists(directory):
            os.makedirs(directory)

class ChallengeRepo():
    """ A class to read and write challenges to disk, categorised by activity bundle id.
    
    When instantiated, this class loads all challenges from a standard location
    on disk, then persists the challenges when any changes are made. If multiple
    instances exist, this could lead to problems with changes from one being
    overwritten by another, so it is recommended to keep each instance instantiated
    only as long as is necessary. """

    #self._challenges is a map
    #    -key = bundle id
    #    -value = map of challenges
    
    # map of challenges
    #    -key = challenge id
    #    -value = Challenge type

    def __init__(self):
        """ Loads all challenges from disk.
        
        If no challenge file is found, a new empty dict of
        challenges is created instead.
        
        """
        # Unpickle list of challenges if present
        _ensure_dir(CHALLENGE_FILE_PATH)
        try:
            f = open(CHALLENGE_FILE_PATH, 'r')
            self._challenges = pickle.load(f)
            f.close()
        except IOError:
            # file doesn't exist, use empty map
            self._challenges = {}

    def persist_challenges(self):
        """ writes the current challenge map to disk """
        _ensure_dir(CHALLENGE_FILE_PATH)
        try:
            f = open(CHALLENGE_FILE_PATH, 'w')  # write mode to replace any old version of the file
            #TODO need to make sure that changes aren't going to be lost with multiple instances
            # overwriting each other. For now just stick to workflows that will prevent this.
            pickle.dump(self._challenges, f)
            f.close()
        except IOError:
            raise IOError('unable to save challenges')


    def set_challenges(self, bundle_id, challenge_map):
        """ Overwrite all existing challenges for this activity with the
        given challenges.
        
        bundle_id: the bundle id of the activity to which the challenges belong
        challenge_map: a dictionary using challenge id strings as keys, and
                       Challenge objects as values.
                       
        """
        #TODO error checking here to make sure arguments are valid
        self._challenges[bundle_id] = challenge_map
        self.persist_challenges()
    
    def update_challenges(self, bundle_id, challenge_map):
        """ Adds or updates the given challenges. If a challenge is already
        present, it will not be overwritten.
        
        bundle_id: the bundle id of the activity to which the challenges belong
        challenge_map: a dictionary using challenge id strings as keys, and
                       Challenge objects as values.
        
        """
        #TODO check challenge_map is valid
        challenges = self.get_challenges(bundle_id)
        for chal_id, chall in challenge_map.iteritems():
            if chal_id not in challenges:
                challenges[chal_id] = chall
        self.set_challenges(bundle_id, challenges)
    
    
    def get_challenges(self, bundle_id):
        """ Returns all the challenges for an activity bundle.
        
        bundle_id: the bundle id of the activity to which the challenges belong
        
        returns: a dict of all challenges for the given activity bundle, using
                 challenge id string as keys and Challenge objects as values,
                 or an empty dictionary if there are no challenges for the
                 activity.
        
        """
        if (bundle_id in self._challenges):
            return self._challenges[bundle_id]
        else:
            return {}
    
    def get_challenge(self, bundle_id, challenge_id):
        """ Returns a challenge
        
        bundle_id: the bundle id of the activity to which the challenge belongs
        challenge_id: the unique id string for the challenge within the activity
        
        returns: the challenge with the given id, or None if
                 there is no challenge with the given id for
                 the given activity bundle.
        
        """
        challenges = self.get_challenges(bundle_id)
        if challenges is None:
            return None
        if challenge_id in challenges:
            return challenges[challenge_id]
        return None
    
    def set_challenge(self, bundle_id, challenge_id, challenge):
        """ Sets the challenge for a challenge id, overwriting any
        existing challenge with the same id for the given activity
        bundle.
        
        bundle_id: the bundle id of the activity to which the challenge belongs
        challenge_id: the unique id string for the challenge within the activity
        challenge: a Challenge object to replace any existing challenge
                   with the same id.
        
        """
        challenges = self.get_challenges(bundle_id)
        if challenges is None:
            return {challenge_id, challenge}
        challenges[challenge_id] = challenge
        self.set_challenges(bundle_id, challenges)
    
    def get_result(self, bundle_id, challenge_id):
        """ Returns the result for a challenge
        
        bundle_id: the bundle id of the activity to which the challenge belongs
        challenge_id: the unique id string for the challenge within the activity
        
        returns: the Result object for the challenge, or None if there
                 is no challenge with the given id for the given activity
                 bundle.
        
        """
        challenge = self.get_challenge(bundle_id, challenge_id)
        if challenge is None:
            return None
        return challenge._result
    
    def set_result(self, bundle_id, challenge_id, result):
        """ Replaces the result for a challenge
        
        bundle_id: the bundle id of the activity to which the challenge belongs
        challenge_id: the unique id string for the challenge within the activity
        result: a Result object to replace the existing result object for the challenge
        
        returns: True if the result was replaced successfully, or
                 False if there was no challenge with the given id
                 and no replacement occurred.
        
        """
        challenge = self.get_challenge(bundle_id, challenge_id)
        if challenge is not None:
            challenge._result = result
            self.set_challenge(bundle_id, challenge_id, challenge)
            return True
        return False


class Challenge():
    """Represents a challenge that can be completed in an activity.

    Each challenge is associated with a particular activity by bundle
    id, and has a challenge id that is unique within the activity.

    This class aims to encapsulate everything that is required for
    dealing with challenges, including the current maximum results that
    have been achieved for the challenge by the user, and how this
    result is used to calculate whether the challenge has been achieved.
    
    bundle_id: the bundle id for the activity to which this challenge
               belongs, corresponding to the value of bundle_id in the
               activity.info file.
    challenge_id: a string id for this challenge that is unique within
                  this activity bundle.
    description: a user-friendly description for this challenge that
                 will be displayed in Glycogen's user interface. Can
                 include a placeholder '{target}' where the target
                 result will be displayed in the Glycogen UI.
                 e.g. if the target result is 10, the description string
                 "Answer {target} questions correctly" would be
                 displayed as "Answer 10 questions correctly"
    result: a Result object

    """
    
    def __init__(self, bundle_id, challenge_id, description, result):
        self._bundle_id = bundle_id
        self._challenge_id = challenge_id
        self._description = description
        self._result = result
    
    def get_id(self):
        """returns: the id string for this challenge"""
        return self._challenge_id
    
    def get_description(self):
        """returns: the description for this challenge.
        May contain a '{target}' format placeholder."""
        return self._description
    
    def complete(self):
        """Indicates whether this challenge is complete.
        
        returns: True if there is an actual result that exceeds
                 the target result, False otherwise.
        
        """
        result = self.get_result()
        if result is None:
            return False
        else:
            return result.achieved()
    
    def get_result(self):
        """returns: the Result object for this challenge"""
        self._result = ChallengeRepo().get_result(self._bundle_id, self._challenge_id)
        return self._result
    
    #TODO getters and setters for properties


class Result():
    """ Represents the result for a challenge. Includes target and actual
    results that have been achieved, and the logic for determining whether
    the challenge is complete.
    
    target: the default target result. The current result is compared with
            this to determine whether the challenge is complete (unless a
            custom target has been set)
    success_function: a function that takes two arguments named 'target'
                      and 'result' in any order, both of the same type as
                      the default target, and returns True if the value of
                      result is as advanced as or more advanced than target.
                      
                      In the current implementation, success_function must
                      be available in the installed python libraries, so
                      should be a member of glycogen.challenge.result module.
    
    """

    def __init__(self, target, success_function):
        #TODO error checking for valid type (bool/int/float)
        self._result_type = type(target)
        self._default_target = target
        self._success_function = success_function
        self._custom_target = None
        self._result = None

    def set_target(self, target):
        """Sets a custom target result that will supercede
        (but not replace) the default target.
        
        target: the custom target result, must be the same type
                as the default target set in the constructor.
                
        raises: Exception if target is not of the same type as
                the default target set in the constructor.
        
        """
        if isinstance(target, self._result_type):
            self._custom_target = target
        else:
            raise Exception("invalid type for target, expected %s but was %s" % (self._result_type, type(target)))

    def set_result(self, result):
        """Replaces the currently achieved result with the given result value.
        
        result: the current or most advanced result value achieved by the user,
                must be the same type as the default target set in the constructor.
        
        raises: Exception if result is not of the same type as
                the default target set in the constructor.
        
        """
        if isinstance(result, self._result_type):
            self._result = result
        else:
            raise Exception("invalid type for result, expected %s but was %s" % (self._result_type, type(target)))
    
    def get_result(self):
        """ Returns the current result the user has achieved. May be None."""
        return self._result
    
    def get_target(self):
        """ Returns the most appropriate target result.
        
        If a custom target has been set, this is returned, otherwise
        the default target is returned.
        
        """
        
        if (self._custom_target is not None):
            return self._custom_target
        else:
            return self._default_target
    
    def achieved(self):
        """ Indicates whether the target has been reached.
        
        returns: true if the success function returns true given the target and result
        
        """
        return self._success_function(target=self.get_target(), result=self.get_result())




# This is probably a better alternative to a singleton implementation
# It is certainly a lot clearer and simpler

#_repo_instance = None

def get_global_repository():  # named to make it clear that a single global repo is used
    """ DEPRECATED, create a short-lived instance of ChallengeRepo instead.
    
    Returns a new ChallengeRepo() instance.
    """
    #TODO refactor code that uses this. Singleton style implementation is not
    # suitable here as activities appear to run in a sandbox environment that
    # will not return the same instance that the UI uses. Relying on writing
    # and reading from disk instead (not ideal but should be alright in this
    # environment with its lack of multitasking, as long as instances are short-
    # lived).
    
    #if globals()['_repo_instance'] is None:
    #    globals()['_repo_instance'] = ChallengeRepo()
    #return globals()['_repo_instance']
    
    return ChallengeRepo()  #Returns a new instance to prevent ui and activity instances getting out of sync


if __name__ == '__main__':
    r1 = get_global_repository()
    print r1._challenge
    r1.add_challenge("adding challenge")
    print r1._challenge

    r2 = get_global_repository()
    print r2._challenge
