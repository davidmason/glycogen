
import os
import pickle

#TODO figure out what is the best path to use here
#TODO possibly use one file per bundle id, to improve stability and performance
#CHALLENGE_FILE_PATH = '/tmp/glycogen/challenges'
CHALLENGE_FILE_PATH = '/home/sugar/challenges/chal'


# utility method to make sure the directory exists to put the challenges in
def ensure_dir(file_path):
    directory = os.path.dirname(file_path)
    if directory:
        if not os.path.exists(directory):
            os.makedirs(directory)

class ChallengeRepo():

    #self._challenges is a map
    #    -key = bundle id
    #    -value = map of challenges
    
    # map of challenges
    #    -key = challenge id
    #    -value = Challenge type

    def __init__(self):
        # Unpickle list of challenges if present
        ensure_dir(CHALLENGE_FILE_PATH)
        try:
            f = open(CHALLENGE_FILE_PATH, 'r')
            self._challenges = pickle.load(f)
            f.close()
        except IOError:
            # file doesn't exist, use empty map
            self._challenges = {}

    def persist_challenges(self):
        ensure_dir(CHALLENGE_FILE_PATH)
        try:
            f = open(CHALLENGE_FILE_PATH, 'w')  # write mode to replace any old version of the file
            #TODO need to make sure that changes aren't going to be lost with multiple instances
            # overwriting each other. For now just stick to workflows that will prevent this.
            pickle.dump(self._challenges, f)
            f.close()
        except IOError:
            raise IOError('unable to save challenges')


    def set_challenges(self, bundle_id, challenge_map):
        """ Overwrite all existing challenges for this activity with the
        given challenges.

        challenge_map should use a challenge id as key, which can be
        anything as long as it is unique within the activity. Values should
        be properly instantiated Challenge objets.

        """
        #TODO error checking here to make sure arguments are valid
        self._challenges[bundle_id] = challenge_map
        self.persist_challenges()
    
    def update_challenges(self, bundle_id, challenge_map):
        """ Adds or updates the given challenges. If a challenge is already
        present, it will not be overwritten. """
        #TODO check challenge_map is valid
        challenges = self.get_challenges(bundle_id)
        for chal_id, chall in challenge_map.iteritems():
            if chal_id not in challenges:
                challenges[chal_id] = chall
        self.set_challenges(bundle_id, challenges)
    
    
    def get_challenges(self, bundle_id):
        if (bundle_id in self._challenges):
            return self._challenges[bundle_id]
        else:
            return {}
    
    def get_challenge(self, bundle_id, challenge_id):
        challenges = self.get_challenges(bundle_id)
        if challenges is None:
            return None
        if challenge_id in challenges:
            return challenges[challenge_id]
        return None
    
    def set_challenge(self, bundle_id, challenge_id, challenge):
        challenges = self.get_challenges(bundle_id)
        if challenges is None:
            return {challenge_id, challenge}
        challenges[challenge_id] = challenge
        self.set_challenges(bundle_id, challenges)
    
    def get_result(self, bundle_id, challenge_id):
        challenge = self.get_challenge(bundle_id, challenge_id)
        if challenge is None:
            return None
        return challenge._result
    
    def set_result(self, bundle_id, challenge_id, result):
        challenge = self.get_challenge(bundle_id, challenge_id)
        challenge._result = result
        self.set_challenge(bundle_id, challenge_id, challenge)


class Challenge():
    """Represents a challenge that can be completed in an activity.

    Each challenge is associated with a particular activity by bundle
    id, and has a challenge id that is unique within the activity.

    This class aims to encapsulate everything that is required for
    dealing with challenges, including the current maximum results that
    have been achieved for the challenge by the user, and how this
    result is used to calculate whether the challenge has been achieved.

    A challenge that is used in a pathway may have a target value, which
    is a custom value set for the specific instance of the challenge
    in that pathway alone. If present, this value will be used rather
    than the default target value.

    """
    
    def __init__(self, bundle_id, challenge_id, description, result):
        self._bundle_id = bundle_id
        self._challenge_id = challenge_id
        self._description = description
        self._result = result
    
    def get_id(self):
        return self._challenge_id
    
    def get_description(self):
        return self._description
    
    def complete(self):
        self._result = ChallengeRepo().get_result(self._bundle_id, self._challenge_id)
        return self._result.achieved()
    
    #TODO getters and setters for properties


class Result():
    """ Represents the result for a challenge, including target and actual
    results that have been achieved, and the logic for determining whether
    the challenge is complete.
    
    Default target and a success function must be provided.
    
    success_function must take exactly 2 arguments named 'target' and
    'result' (order is not important)
    
    """

    def __init__(self, target, success_function):
        #TODO error checking for valid type (bool/int/float)
        self._result_type = type(target)
        self._default_target = target
        self._success_function = success_function
        self._custom_target = None
        self._result = None

    def set_target(self, target):
        if isinstance(target, self._result_type):
            self._custom_target = target
        else:
            raise Exception("invalid type for target, expected %s but was %s" % (self._result_type, type(target)))

    def set_result(self, result):
        if isinstance(result, self._result_type):
            self._result = result
        else:
            raise Exception("invalid type for result, expected %s but was %s" % (self._result_type, type(target)))
    
    def get_result(self):
        return self._result
    
    def get_target(self):
        """ Returns the most appropriate target result.
        
        If a custom target has been set, this is returned, otherwise
        the default target is returned.
        
        """
        
        if (self._custom_target is not None):
            return self._custom_target
        else:
            return self._default_target
    
    def achieved(self):
        return self._success_function(target=self.get_target(), result=self.get_result())




# This is probably a better alternative to a singleton implementation
# It is certainly a lot clearer and simpler

_repo_instance = None

def get_global_repository():  # named to make it clear that a single global repo is used
    if globals()['_repo_instance'] is None:
        globals()['_repo_instance'] = ChallengeRepo()
    return globals()['_repo_instance']


if __name__ == '__main__':
    r1 = get_global_repository()
    print r1._challenge
    r1.add_challenge("adding challenge")
    print r1._challenge

    r2 = get_global_repository()
    print r2._challenge
