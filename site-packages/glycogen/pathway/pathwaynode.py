#TODO add GPL


from challenge import Challenge

#TODO put this in the view (gui) part
_SIMPLE_NODE_HEIGHT = 10  #TODO set a value
_SIMPLE_NODE_WIDTH = 10  #TODO set a value

class PathwayNode(object):
    """An abstract representation of a node in a learning pathway.
    
    This is designed to be overridden to produce simple nodes (such as
    the start and end node), challenge nodes, serial nodes and parallel
    nodes.
    
    """
    
    def __init__(self, before=None, after=None):
        
	#TODO check that before is a PathwayNode
	self.before = before
	#TODO check that after is a PathwayNode
	self.after = after

	#TODO these should be in the GUI part of the pathway code
        self.height = _SIMPLE_NODE_HEIGHT
	self.width = _SIMPLE_NODE_WIDTH

    def add_after(self, node):
        # hook after to node
	self.after.before = node
        node.after = self.after
	#hook node to this
	node.before = self
	self.after = node

    def add_before(self, node):
        # hook previous to node
	self.before.after = node
        node.before = self.before
	# hook node to this
	node.after = self
	self.before = node

    def add_above(self, node):
        before = self.before
	after = self.after
	parallel_node = ParallelNode(before=self.before, after=self.after, top=node, bottom=self)
	before.after = parallel_node
	after.before = parallel_node

    def add_below(self, node):
        before = self.before
	after = self.after
	parallel_node = ParallelNode(before=self.before, after=self.after, top=node, bottom=self)
	before.after = parallel_node
	after.before = parallel_node

class SimpleNode(PathwayNode):
    """Abstract class for pathway nodes that cannot be manipulated in all the normal ways"""

    def __init__(self, before=None, after=None):
        PathwayNode.__init__(self, before, after)

    def add_above(self, node):
        raise Exception("cannot add a node above a simple node")

    def add_below(self, node):
        raise Exception("cannot add a node below a simple node")
    
class StartNode(SimpleNode):
    """"""

    def __init__(self, after=None):
        SimpleNode.__init__(self, before=None, after=after)

    def complete(self):
        return True

    def add_before(self, node):
        raise Exception("cannot add a node before a start node")


class EndNode(SimpleNode):
    """"""

    def __init__(self, before=None):
        SimpleNode.__init__(self, before, after=None)

    def complete(self):
        return self.before.complete()

    def add_after(self, node):
        raise Exception("cannot add a node after an end node")


class ChallengeNode(PathwayNode):
    """A simple node that encapsulates a challenge"""

    def __init__(self, before=None, after=None, challenge=None):
        PathwayNode.__init__(self, before, after)

	#TODO check that challenge is an appropriate type (a challenge info type)
	self.challenge = challenge
    
    def complete(self):
        return challenge.complete()



class ParallelNode(PathwayNode):
    """A node that encapsulates two parallel strings of nodes"""
    
    def __init__(self, before=None, after=None, top=None, bottom=None):
        PathwayNode.__init__(self, before, after)

	self.first = SplitNode(self)
	self.last = MergeNode(self)

	self.first.top.after = self.last.top
	self.first.bottom.after = self.last.bottom
	self.last.top.before = self.first.top
	self.last.bottom.before = self.first.bottom

	if top:
	    self.first.top.add_after(top)
	if bottom:
	    self.first.bottom.add_after(bottom)

    def complete(self):
        return self.last.complete()


class SplitNode():
    
    def __init__(self, parent):
        self.parent = parent
	self.top = SplitStart(self)
	self.bottom = SplitStart(self)

    def complete(self):
        return self.parent.before.complete()

class MergeNode():

    def __init__(self, parent):
        self.parent = parent
	self.top = SplitEnd(self)
	self.bottom = SplitEnd(self)

    def complete(self):
        return self.top.complete() and self.bottom.complete()

class SplitStart(StartNode):
    def __init__(self, parent):
        StartNode.__init__(self)
        self.parent = parent

    def complete(self):
        return self.parent.complete()

class SplitEnd(EndNode):
    def __init__(self, parent):
        EndNode.__init__(self)
        self.parent = parent

