import unittest
from challenge import Challenge
from learningpathway import LearningPathway
from pathwaynode import *  #TODO replace with specifics

class ChallengeTestCase(unittest.TestCase):
    
    def testChallenge(self):
        my_challenge = Challenge("identifier")
        self.assertEqual("identifier", my_challenge.identifier)

    def testChallengeComplete(self):
        my_challenge = Challenge()
        #TODO test real condition against activity challenge
        self.assertTrue(my_challenge.complete())

def dummy_complete_true():
    return True

def dummy_complete_false():
    return False
    
class LearningPathwayTestCase(unittest.TestCase):
    def testEmptyPathway(self):
        pathway = LearningPathway()
        self.assertEqual(pathway.start.after, pathway.finish)
        self.assertEqual(pathway.finish.before, pathway.start)
        self.assertTrue(pathway.complete())

    def testSingleChallenge(self):
        pathway = LearningPathway()
        first_node = ChallengeNode(Challenge("first"))
        pathway.start.add_after(first_node)

        self.assertEqual(pathway.start.after, first_node)
        self.assertEqual(pathway.start, first_node.before)
        self.assertEqual(pathway.finish.before, first_node)
        self.assertEqual(pathway.finish, first_node.after)

        # overriding the node's complete() function to test pathway  behaviour
        first_node.complete = dummy_complete_true
        self.assertTrue(pathway.complete())

        first_node.complete = dummy_complete_false
        self.assertFalse(pathway.complete())


def pathway_to_list(pathway):
    first = pathway.start
    last = pathway.finish
    next_node = first.after
    path_list = []
    while next_node is not last:
        path_list.append(node_to_list(next_node))
        next_node = next_node.after
    return path_list

def node_to_list(node):
    if type(node) is ParallelNode:
        return parallel_node_to_list(node)
    if type(node) is ChallengeNode:
        return node.challenge.identifier
    return "unknown"

def parallel_node_to_list(node):
    top_list = []
    next_node = node.first.top.after
    last = node.last.top
    while next_node is not last:
        top_list.append(node_to_list(next_node))
        next_node = next_node.after

    bottom_list = []
    next_node = node.first.bottom.after
    last = node.last.bottom
    while next_node is not last:
        bottom_list.append(node_to_list(next_node))
        next_node = next_node.after

    return [top_list, bottom_list]

if __name__ == "__main__":
    # this test is to try out the learning pathway as I make it

    pathway = LearningPathway()

    # add a challenge node after the start
    first_challenge = Challenge("first")
    first_node = ChallengeNode(challenge=first_challenge)

    pathway.start.add_after(first_node)
    print pathway_to_list(pathway)

    second_challenge = Challenge("second")
    second_node = ChallengeNode(challenge=second_challenge)
    first_node.add_after(second_node)

    print pathway_to_list(pathway)

    # add a challenge node before the end
    last_challenge = Challenge("last")
    last_node = ChallengeNode(challenge=last_challenge)
    pathway.finish.add_before(last_node)

    print pathway_to_list(pathway)

    # add a node above the second
    above_challenge = Challenge("above")
    above_node = ChallengeNode(challenge=above_challenge)
    second_node.add_above(above_node)

    print pathway_to_list(pathway)

    # add a node below the above node
    below_node = ChallengeNode(challenge=Challenge("below"))
    above_node.add_below(below_node)

    print pathway_to_list(pathway)


unittest.main()
